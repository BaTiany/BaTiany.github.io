<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Clearlove&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-16T16:18:45.726Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Massif</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React生命周期</title>
    <link href="http://yoursite.com/2019/07/16/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2019/07/16/React生命周期/</id>
    <published>2019-07-16T15:34:40.000Z</published>
    <updated>2019-07-16T16:18:45.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-生命周期"><a href="#React-生命周期" class="headerlink" title="React 生命周期"></a>React 生命周期</h1><p>React 生命周期分为三大阶段，挂载、更新、销毁</p><hr><a id="more"></a><p><img src="https://upload-images.jianshu.io/upload_images/5287253-82f6af8e0cc9012b.png?imageMogr2/auto-orient/" alt="img.png"></p><h1 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h1><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor()"></a>constructor()</h2><p>在安装 React 组件之前，会调用它的构造函数。</p><p>通常，在 React 中，构造函数仅用于两个目的：</p><ul><li>初始化数据<code>this.state</code>。</li><li>绑定 <code>this</code> 指向。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line">  <span class="comment">// Don't call this.setState() here!</span></span><br><span class="line">  <span class="keyword">this</span>.state = &#123; <span class="attr">counter</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="componentDidMount-组件挂载完成"><a href="#componentDidMount-组件挂载完成" class="headerlink" title="componentDidMount() 组件挂载完成"></a>componentDidMount() 组件挂载完成</h2><p>主要用于：</p><ul><li>获取异步数据，</li><li>操作 dom 之类</li></ul><h2 id="render-渲染"><a href="#render-渲染" class="headerlink" title="render() 渲染"></a>render() 渲染</h2><p>默认进来一次，后续如果有更新会再次触发</p><hr><h1 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h1><h2 id="getDerivedStateFromProps"><a href="#getDerivedStateFromProps" class="headerlink" title="getDerivedStateFromProps()"></a>getDerivedStateFromProps()</h2><p>能够让我们根据 props 的数据来设置 state 数据</p><ul><li><p>初始化 render 之前调用一次</p></li><li><p>后续数据有变化，重新 render 之前又会调用</p></li><li><p>不能使用 this.setState</p></li><li><p>需要 return { } | null 如果是 { } ，会将这个 { } 与 state 合并</p></li></ul><h2 id="shouldComponentUpdate-nextProps-nextState"><a href="#shouldComponentUpdate-nextProps-nextState" class="headerlink" title="shouldComponentUpdate(nextProps, nextState)"></a>shouldComponentUpdate(nextProps, nextState)</h2><p>可以用来性能优化，但是不常用</p><h2 id="componentDidUpdate-更新完成"><a href="#componentDidUpdate-更新完成" class="headerlink" title="componentDidUpdate() 更新完成"></a>componentDidUpdate() 更新完成</h2><p>componentDidUpdate() 更新发生后立即调用。初始渲染不会调用此方法。</p><p>将此作为在更新组件时对 DOM 进行操作的机会。只要您将当前道具与之前的道具进行比较（例如，如果道具未更改，则可能不需要网络请求），这也是进行网络请求的好地方。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate(prevProps) &#123;</span><br><span class="line">  <span class="comment">// Typical usage (don't forget to compare props):</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.props.userID !== prevProps.userID) &#123;</span><br><span class="line">    <span class="keyword">this</span>.fetchData(<span class="keyword">this</span>.props.userID);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h1><h2 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount()"></a>componentWillUnmount()</h2><p>componentWillUnmount() 在卸载和销毁组件之前立即调用。在此方法中执行任何必要的清理，例如使计时器无效，取消网络请求或清除在其中创建的任何订阅 componentDidMount()。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;React-生命周期&quot;&gt;&lt;a href=&quot;#React-生命周期&quot; class=&quot;headerlink&quot; title=&quot;React 生命周期&quot;&gt;&lt;/a&gt;React 生命周期&lt;/h1&gt;&lt;p&gt;React 生命周期分为三大阶段，挂载、更新、销毁&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React</title>
    <link href="http://yoursite.com/2019/07/16/React/"/>
    <id>http://yoursite.com/2019/07/16/React/</id>
    <published>2019-07-16T15:02:51.000Z</published>
    <updated>2019-07-16T15:33:24.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><p>React 是一个用于构建用户界面的 JAVASCRIPT 库，主要用于构建 UI，很多人认为 React 是 MVC 中的 V（视图），并且 React 拥有较高的性能，代码逻辑非常简单。React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。</p><hr><a id="more"></a><h1 id="JSX-语法"><a href="#JSX-语法" class="headerlink" title="JSX 语法"></a>JSX 语法</h1><p>JSX 通俗来说就是 JavaScript 与 XML</p><p>JSX 语法的特点：</p><ol><li><p>单个根元素<br></p></li><li><p>单标签一定要闭合<br></p></li><li><p>img 标签一定要有 alt 属性 <br></p></li><li><p>标签都是小写字母，组件首字母大写<br></p></li><li><p>class 要写成 className</p></li><li><p>for 要写成 htmlFor</p></li><li><p>写 style 样式要写成对象的形式</p></li></ol><p>jsx 的注释：使用 js 的注释</p><p>jsx 的插值表达式</p><ul><li><p>使用单个 花括号 来作为表达式</p></li><li><p>只能是简单的单个表达式，不能是语句也不能是条件或循环语句。</p></li><li><p>如果要使用条件的，可以采用 三元运算符（三目运算符）<br>{ ‘’ } | { false } | {null} | {undefined} 这些情况的话，会没有任何输出</p></li><li><p>v-html 需要时 <code>dangerouslySetInnerHTML</code>这个属性，<br><code>dangerouslySetInnerHTML</code> 这个属性需要接受一个对象的 value</p></li></ul><hr><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p>React 中没有全局组件的概念，你要使用哪个组件，必须要引入进来使用</p><p>组件的定义</p><p>函数式组件</p><ul><li><p>定义一个函数，然后 return 出来一段 jsx 语法。这一段 jsx 语法就是这个组件的模板内容</p></li><li><p>函数名字就是组件的名字，所以首字母要大写</p></li></ul><p>类组件</p><ul><li><p>定义一个类，类名就是组件名（大写首字母）</p></li><li><p>这个类需要继承 React.Component 这个基础组件<br>类中的 render 函数是必须，render 函数 return 出来是一段 jsx 语法，这一段 jsx 语法就是这个组件的模板内容</p></li></ul><p>组件的注意事项</p><ul><li><p>组件的模板内容，如果需要换行去写的话，那么请使用 ( ) 包裹起来</p></li><li><p>组件的模板内容是 jsx 语法，所以还需要保证 jsx 特点</p></li></ul><hr><h1 id="组件的-props-属性"><a href="#组件的-props-属性" class="headerlink" title="组件的 props 属性"></a>组件的 props 属性</h1><ul><li>调用组件时，在组件标签上写的属性，属性名就是个 prop</li></ul><ul><li>props 是个集合 ， prop 是具体的某一个</li></ul><ul><li>vue 中要使用 props. 首先需要在组件中定义 props 的选项，而 react 中不需要</li></ul><p>组件 prop 的校验</p><p>需要安装 prop-types 的模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev prop-types</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">yarn add prop-types -D</span><br></pre></td></tr></table></figure><h1 id="组件中的-State"><a href="#组件中的-State" class="headerlink" title="组件中的 State"></a>组件中的 State</h1><p>State 与 props 类似，但是 state 是私有的，并且完全受控于当前组件</p><p>组件有没有状态，主要就看这个组件有没有 state</p><p>一般 类组件就可以称为 有状态组件， 函数组件 叫 无状态组件</p><p>想让组件自己去更新 UI，那么首先需要让这个组件有自己的 state。 然后 state 如果发生变化，它就会重新渲染。</p><p>组件要有变化，两种方式</p><ul><li><p>组件接收到的 props 有了变化</p></li><li><p>组件自身的 state 有了变化，组件的 state 或 props 有变化，组件就会更新，更新的效果其实就是类组件的 render 函数重新执行了，函数组件重新调用了</p></li></ul><p>PS: 1. 如果要让组件有 state, 首先要确保这个组件是类组件。</p><ol start="2"><li>要在 构造函数中定义 状态的初始值。 3. 写了 构造函数的话，就必须在构造函数的第一行调用父类的构造函数 super()</li></ol><hr><h1 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h1><p>父组件 – &gt; 子组件： <code>porp</code></p><p>子组件 –&gt; 父组件:</p><ul><li><p>调用子组件的时候，传递一个自己的方法下去，这个方法里面有修改自己 state 的功能</p></li><li><p>子组件通过 this.props.propName()</p></li></ul><hr><h1 id="事件处理函数需要-修改-this-指向"><a href="#事件处理函数需要-修改-this-指向" class="headerlink" title="事件处理函数需要 修改 this 指向"></a>事件处理函数需要 修改 this 指向</h1><ul><li><p>不能使用 apply 与 call,apply 与 call 会立即执行，而 bind 是返回一个新的函数</p></li><li><p>jsx bind （ 不推荐 ）</p></li><li><p>箭头函数 （ 不推荐 ）</p></li><li><p>统一在 构造函数 中去做 this 绑定 （ 推荐 ）</p></li><li><p>使用 实验性 public class fields 语法 （ 推荐 ）</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;React&quot;&gt;&lt;a href=&quot;#React&quot; class=&quot;headerlink&quot; title=&quot;React&quot;&gt;&lt;/a&gt;React&lt;/h1&gt;&lt;p&gt;React 是一个用于构建用户界面的 JAVASCRIPT 库，主要用于构建 UI，很多人认为 React 是 MVC 中的 V（视图），并且 React 拥有较高的性能，代码逻辑非常简单。React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>ECMASript 6</title>
    <link href="http://yoursite.com/2019/07/16/ES6%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2019/07/16/ES6新特性/</id>
    <published>2019-07-16T02:59:45.000Z</published>
    <updated>2019-07-16T11:48:49.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ECMASript-6"><a href="#ECMASript-6" class="headerlink" title="ECMASript 6"></a>ECMASript 6</h1><hr><p>在 React 和 Vue 中使用了大量的 ES6 语法，本文简单的总结了 ES6 的一些基本特性</p><a id="more"></a><hr><h1 id="Babel转码器"><a href="#Babel转码器" class="headerlink" title="Babel转码器"></a><code>Babel</code>转码器</h1><p><code>Babel</code> 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在现有环境执行。可通过以下命令安装在项目目录中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @babel/core</span><br></pre></td></tr></table></figure><hr><h1 id="let与const命令"><a href="#let与const命令" class="headerlink" title="let与const命令"></a><code>let</code>与<code>const</code>命令</h1><h2 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a><code>let</code> 命令</h2><blockquote><p>let 用来声明变量，用法类似于 var，但是声明的变量只在<code>let</code>命令所`在的代码块有效</p></blockquote><h2 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a><code>const</code> 命令</h2><blockquote><p>const 声明常量，一旦声明不得修改赋值，必须初始化</p></blockquote><h2 id="let-const-var的区别"><a href="#let-const-var的区别" class="headerlink" title="let const var的区别"></a><code>let const var</code>的区别</h2><blockquote><p>1、var 有变量提升，let 与 const 没有<br><br>2、var 定义的变量可以修改，如果不初始化会输出 undefined，不会报错。<br><br>3、const 定义的变量不可以修改，而且必须初始化。<br><br>4、let 是块级作用域，函数内部使用 let 定义后，对函数外部无影响。</p></blockquote><hr><h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">"老王"</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;;</span><br><span class="line"><span class="comment">// 解构为</span></span><br><span class="line"><span class="keyword">var</span> &#123; name, age &#125; = obj;</span><br><span class="line">name; <span class="comment">// 老王</span></span><br><span class="line">age; <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><hr><h1 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h1><p>扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line"><span class="built_in">console</span>.log(...str); <span class="comment">// a,b,c</span></span><br></pre></td></tr></table></figure><p>可用于复制数组</p><p>数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> a2 = [...a1];</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> [...a2] = a1;</span><br></pre></td></tr></table></figure><hr><h1 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h1><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#result"</span>).append(</span><br><span class="line">  <span class="string">"There are &lt;b&gt;"</span> +</span><br><span class="line">    basket.count +</span><br><span class="line">    <span class="string">"&lt;/b&gt; "</span> +</span><br><span class="line">    <span class="string">"items in your basket, "</span> +</span><br><span class="line">    <span class="string">"&lt;em&gt;"</span> +</span><br><span class="line">    basket.onSale +</span><br><span class="line">    <span class="string">"&lt;/em&gt; are on sale!"</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#result"</span>).append(<span class="string">`</span></span><br><span class="line"><span class="string">  There are &lt;b&gt;<span class="subst">$&#123;basket.count&#125;</span>&lt;/b&gt; items</span></span><br><span class="line"><span class="string">   in your basket, &lt;em&gt;<span class="subst">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</span></span><br><span class="line"><span class="string">  are on sale!</span></span><br><span class="line"><span class="string">`</span>);</span><br></pre></td></tr></table></figure><p>模板字符串嵌入变量，需要将变量写入<code>${}</code>中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"Bob"</span>,</span><br><span class="line">  time = <span class="string">"today"</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span>;</span><br></pre></td></tr></table></figure><hr><h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>ES6 允许使用“箭头”（=&gt;）定义函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p>ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p><hr><h1 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h1><h2 id="promis-简介"><a href="#promis-简介" class="headerlink" title="promis 简介"></a>promis 简介</h2><blockquote><p>Promise 对象用于异步操作，它表示一个尚未完成且预计在未来完成的异步操作。<br></p></blockquote><ul><li><p>Promise 对象有两个特点</p><p>（1）对象的状态不受外界影响。promise 对象代表一个异步操作，分为三个状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）</p><p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。改变状态的两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。</p></li><li><p>Promise 对象的缺点</p><p>（1）无法取消，一旦新建会立刻执行</p><p>（2）如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部</p><p>（3）当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p></li></ul><h2 id="Promsie-用法"><a href="#Promsie-用法" class="headerlink" title="Promsie 用法"></a>Promsie 用法</h2><p>Promise 对象是一个构造函数，用来生成 Promise 实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Promise 对象接收两个参数</p><p><code>resolve()</code> 在异步操作成功时调用，并将异步操作的结果，作为参数传递出去</p><p><code>reject()</code> 在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p><hr><h1 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h1><p>Generator 函数是 ES6 提供的一种异步编程解决方案。</p><p>特征：<br>function 与函数名之间有个星号（*）</p><p>函数体内部使用<code>yield</code>表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"hello"</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"world"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"ending"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h1><p>async 函数就是 Generator 函数的语法糖，把 Generator 函数里面的星号（*）替换成 async，yield 替换成 await。</p><ul><li>await 函数返回一个 Promise 对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> timeout(ms);</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncPrint(<span class="string">"hello world"</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p>上面代码指定 50 毫秒以后，输出 hello world。</p><p>使用注意点</p><ul><li>await 返回一个 Promise 对象，所以 await 命令最好放在 try…catch 语句中</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sleep = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">123</span>);</span><br><span class="line">      resolve(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// reject(new Error("我错了"));</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="keyword">await</span> sleep();</span><br><span class="line">    <span class="built_in">console</span>.log(str);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">456</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">main();</span><br></pre></td></tr></table></figure><ul><li>await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。</li></ul><p>async 函数与 Promise、Generator 函数的比较，async 函数更简洁，更具有语义，但是 async 不要滥用，会造成页面堵塞</p><hr><h1 id="class-继承"><a href="#class-继承" class="headerlink" title="class 继承"></a>class 继承</h1><p>Class 可以通过 extends 关键字实现继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了一个 ColorPoint 类，该类通过 extends 关键字，继承了 Point 类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个 Point 类。下面，我们在 ColorPoint 内部加上代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y, color) &#123;</span><br><span class="line">    <span class="keyword">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span></span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.color + <span class="string">" "</span> + <span class="keyword">super</span>.toString(); <span class="comment">// 调用父类的toString()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，constructor 方法和 toString 方法之中，都出现了 super 关键字，它在这里表示父类的构造函数，用来新建父类的 this 对象。</p><p>子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类自己的 this 对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用 super 方法，子类就得不到 this 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">    <span class="keyword">super</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个需要注意的地方是，在子类的构造函数中，只有调用 super 之后，才可以使用 this 关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有 super 方法才能调用父类实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y, color) &#123;</span><br><span class="line">    <span class="keyword">this</span>.color = color; <span class="comment">// ReferenceError</span></span><br><span class="line">    <span class="keyword">super</span>(x, y);</span><br><span class="line">    <span class="keyword">this</span>.color = color; <span class="comment">// 正确</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，子类的 constructor 方法没有调用 super 之前，就使用 this 关键字，结果报错，而放在 super 方法之后就是正确的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> hello() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello world"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">B.hello(); <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>上面代码中，hello()是 A 类的静态方法，B 继承 A，也继承了 A 的静态方法。</p><h2 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a><code>Object.getPrototypeOf()</code></h2><p><code>Object.getPrototypeOf</code> 方法可以用来从子类上获取父类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(ColorPoint) === Point;</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p><h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a><code>super</code> 关键字</h2><p><code>super</code> 既可以当函数使用，也可以当对象使用</p><ul><li>当做函数调用时，代表父类的构造函数,只能用在子类的构造函数之中，用在其他地方就会报错。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码，子类 B 的构造函数中的<code>super()</code>,代表调用父类的构造函数</p><p>注意，super 虽然代表了父类 A 的构造函数，但是返回的是子类 B 的实例，即 super 内部的 this 指的是 B 的实例，因此 super()在这里相当于 <code>A.prototype.constructor.call(this)</code>。</p><ul><li><code>super</code> 作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  p() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.p()); <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure><p>上面代码中，子类 B 当中的 super.p()，就是将 super 当作一个对象使用。这时，super 在普通方法之中，指向<code>A.prototype</code>，所以 super.p()就相当于 <code>A.prototype.p()</code>。</p><p>这里需要注意，由于 super 指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过 super 调用的。</p><h2 id="类的-prototype-属性和-proto-属性"><a href="#类的-prototype-属性和-proto-属性" class="headerlink" title="类的 prototype 属性和__proto__属性"></a>类的 <code>prototype</code> 属性和<code>__proto__</code>属性</h2><p>（1）子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</p><p>（2）子类 <code>prototype</code> 属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">B.__proto__ === A; <span class="comment">// true</span></span><br><span class="line">B.prototype.__proto__ === A.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，子类 B 的<code>__proto__</code>属性指向父类 A，子类 B 的 <code>prototype</code> 属性的<code>__proto__</code>属性指向父类 A 的 <code>prototype</code> 属性。</p><p>子类实例的<code>__proto__</code>属性的<code>__proto__</code>属性，指向父类实例的<code>__proto__</code>属性。也就是说，子类的原型的原型，是父类的原型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> ColorPoint(<span class="number">2</span>, <span class="number">3</span>, <span class="string">"red"</span>);</span><br><span class="line"></span><br><span class="line">p2.__proto__ === p1.__proto__; <span class="comment">// false</span></span><br><span class="line">p2.__proto__.__proto__ === p1.__proto__; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，ColorPoint 继承了 Point，导致前者原型的原型是后者的原型。</p><p>因此，通过子类实例的<code>__proto__</code>.<code>__proto__</code>属性，可以修改父类实例的行为。</p><hr><h1 id="MiXin-模式的实现"><a href="#MiXin-模式的实现" class="headerlink" title="MiXin 模式的实现"></a>MiXin 模式的实现</h1><p>Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  a: <span class="string">"a"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">  b: <span class="string">"b"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> c = &#123; ...a, ...b &#125;; <span class="comment">// &#123;a: 'a', b: 'b'&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，c 对象是 a 对象和 b 对象的合成，具有两者的接口。</p><hr><p>本文参考: <a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="noopener">阮大神</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ECMASript-6&quot;&gt;&lt;a href=&quot;#ECMASript-6&quot; class=&quot;headerlink&quot; title=&quot;ECMASript 6&quot;&gt;&lt;/a&gt;ECMASript 6&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;在 React 和 Vue 中使用了大量的 ES6 语法，本文简单的总结了 ES6 的一些基本特性&lt;/p&gt;
    
    </summary>
    
      <category term="ES6特性" scheme="http://yoursite.com/categories/ES6%E7%89%B9%E6%80%A7/"/>
    
    
      <category term="JavaScript 前端 ES6" scheme="http://yoursite.com/tags/JavaScript-%E5%89%8D%E7%AB%AF-ES6/"/>
    
  </entry>
  
  <entry>
    <title>Hexo和GitHub Page 搭建个人博客</title>
    <link href="http://yoursite.com/2019/06/22/Hexo%E5%92%8CGitHub-Page-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2019/06/22/Hexo和GitHub-Page-搭建个人博客/</id>
    <published>2019-06-22T09:04:30.000Z</published>
    <updated>2019-07-11T13:20:05.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="个人博客的搭建"><a href="#个人博客的搭建" class="headerlink" title="个人博客的搭建"></a>个人博客的搭建</h1><hr><h3 id="1-搭建环境"><a href="#1-搭建环境" class="headerlink" title="1.搭建环境"></a>1.搭建环境</h3><h5 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 <a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">Node.js</a></h5><h5 id="安装-github"><a href="#安装-github" class="headerlink" title="安装 github"></a>安装 <a href="https://github.com/" target="_blank" rel="noopener">github</a></h5><hr><a id="more"></a><h3 id="2-安装-hexo"><a href="#2-安装-hexo" class="headerlink" title="2 . 安装 hexo"></a>2 . 安装 hexo</h3><p>2.1 安装 Hexo，在命令行（即 Git Bash）运行以下命令：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>2.2 创建一个文件夹为项目文件夹，然后在此目录下打开 git bash 执行以下命令初始化 Hexo</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>2.3 会生成一系列文件，在站点下启动服务，执行命令如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server  (可简写为  hexo s)</span><br></pre></td></tr></table></figure><p>2.4 浏览器访问网址 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p><p>博客在本地已搭建完成。</p><hr><h3 id="3-与远程关联，这里我使用的是GitHubPages"><a href="#3-与远程关联，这里我使用的是GitHubPages" class="headerlink" title="3 . 与远程关联，这里我使用的是GitHubPages"></a>3 . 与远程关联，这里我使用的是<code>GitHubPages</code></h3><ul><li><p>注册一个 GitHub 账号</p></li><li><p>创建一个仓库，仓库名为&lt;GitHub 账号名&gt;.github.io</p><p><img src="./img/img01.png" alt="img.png"><br><img src="./img/img02.png" alt="img.png"></p></li><li><p>创建完成后，打开设置找到 GitHub Pages</p><p><img src="./img/img03.png" alt="img.png"><br><img src="./img/img04.png" alt="img.png"></p></li><li><p>将本地 Hexo 博客部署到 GithubPages</p><ol><li>安装 hexo-deployer-git 插件。在命令行（即 Git Bash）运行以下命令即可：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ol start="2"><li>修改<code>_config.yml</code>（在站点目录下）。文件末尾修改为：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>注：上面仓库地址是 ssh 地址，需要生成一个 ssh 秘钥，参考：<a href="https://www.jianshu.com/p/f92ed1ca8120" target="_blank" rel="noopener">https://www.jianshu.com/p/f92ed1ca8120</a></p></li><li><p>最后下面三行执行命令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>博客已经部署到了远程，通过 https://&lt;Github 账号名称&gt;.github.io 即可访问</p></li></ul><hr><h3 id="4-博客搭建完成，但是默认主题不好看，可以去下载一些主题"><a href="#4-博客搭建完成，但是默认主题不好看，可以去下载一些主题" class="headerlink" title="4. 博客搭建完成，但是默认主题不好看，可以去下载一些主题"></a>4. 博客搭建完成，但是默认主题不好看，可以去下载一些主题</h3><p><a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="noopener">Theme 选择主题并且 clone</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;个人博客的搭建&quot;&gt;&lt;a href=&quot;#个人博客的搭建&quot; class=&quot;headerlink&quot; title=&quot;个人博客的搭建&quot;&gt;&lt;/a&gt;个人博客的搭建&lt;/h1&gt;&lt;hr&gt;
&lt;h3 id=&quot;1-搭建环境&quot;&gt;&lt;a href=&quot;#1-搭建环境&quot; class=&quot;headerlink&quot; title=&quot;1.搭建环境&quot;&gt;&lt;/a&gt;1.搭建环境&lt;/h3&gt;&lt;h5 id=&quot;安装-Node-js&quot;&gt;&lt;a href=&quot;#安装-Node-js&quot; class=&quot;headerlink&quot; title=&quot;安装 Node.js&quot;&gt;&lt;/a&gt;安装 &lt;a href=&quot;https://nodejs.org/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Node.js&lt;/a&gt;&lt;/h5&gt;&lt;h5 id=&quot;安装-github&quot;&gt;&lt;a href=&quot;#安装-github&quot; class=&quot;headerlink&quot; title=&quot;安装 github&quot;&gt;&lt;/a&gt;安装 &lt;a href=&quot;https://github.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github&lt;/a&gt;&lt;/h5&gt;&lt;hr&gt;
    
    </summary>
    
      <category term="blog" scheme="http://yoursite.com/categories/blog/"/>
    
    
      <category term="blog" scheme="http://yoursite.com/tags/blog/"/>
    
  </entry>
  
</feed>
