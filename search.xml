<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ECMASript 6]]></title>
    <url>%2F2019%2F07%2F16%2FES6%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[ECMASript 6 在 React 和 Vue 中使用了大量的 ES6 语法，本文简单的总结了 ES6 的一些基本特性 Babel转码器Babel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在现有环境执行。可通过以下命令安装在项目目录中。 1npm install --save-dev @babel/core let与const命令let 命令 let 用来声明变量，用法类似于 var，但是声明的变量只在let命令所`在的代码块有效 const 命令 const 声明常量，一旦声明不得修改赋值，必须初始化 let const var的区别 1、var 有变量提升，let 与 const 没有2、var 定义的变量可以修改，如果不初始化会输出 undefined，不会报错。3、const 定义的变量不可以修改，而且必须初始化。4、let 是块级作用域，函数内部使用 let 定义后，对函数外部无影响。 解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。 12345var obj = &#123; name: "老王", age: 20 &#125;;// 解构为var &#123; name, age &#125; = obj;name; // 老王age; // 20 扩展运算符扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。 12let str = ["a", "b", "c"];console.log(...str); // a,b,c 可用于复制数组 数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。 12345const a1 = [1, 2];// 写法一const a2 = [...a1];// 写法二const [...a2] = a1; 模板字符串模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。 123456789$("#result").append( "There are &lt;b&gt;" + basket.count + "&lt;/b&gt; " + "items in your basket, " + "&lt;em&gt;" + basket.onSale + "&lt;/em&gt; are on sale!"); 上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。 12345$("#result").append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 模板字符串嵌入变量，需要将变量写入${}中 123let name = "Bob", time = "today";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`; 箭头函数ES6 允许使用“箭头”（=&gt;）定义函数。 1234567891011var f = () =&gt; 5;// 等同于var f = function() &#123; return 5;&#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; SymbolES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。 Promise 对象promis 简介 Promise 对象用于异步操作，它表示一个尚未完成且预计在未来完成的异步操作。 Promise 对象有两个特点 （1）对象的状态不受外界影响。promise 对象代表一个异步操作，分为三个状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败） （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。改变状态的两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。 Promise 对象的缺点 （1）无法取消，一旦新建会立刻执行 （2）如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部 （3）当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 Promsie 用法Promise 对象是一个构造函数，用来生成 Promise 实例 123456789const promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); Promise 对象接收两个参数 resolve() 在异步操作成功时调用，并将异步操作的结果，作为参数传递出去 reject() 在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Generator 函数Generator 函数是 ES6 提供的一种异步编程解决方案。 特征：function 与函数名之间有个星号（*） 函数体内部使用yield表达式 12345function* helloWorldGenerator() &#123; yield "hello"; yield "world"; return "ending";&#125; async 函数async 函数就是 Generator 函数的语法糖，把 Generator 函数里面的星号（*）替换成 async，yield 替换成 await。 await 函数返回一个 Promise 对象 123456789101112async function timeout(ms) &#123; await new Promise(resolve =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value);&#125;asyncPrint("hello world", 50); 上面代码指定 50 毫秒以后，输出 hello world。 使用注意点 await 返回一个 Promise 对象，所以 await 命令最好放在 try…catch 语句中 123456789101112131415161718192021const sleep = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(123); resolve("abc"); // reject(new Error("我错了")); &#125;, 1000); &#125;);&#125;;const main = async () =&gt; &#123; try &#123; let str = await sleep(); console.log(str); console.log(456); &#125; catch (error) &#123; console.log(error.message); &#125;&#125;;main(); await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。 async 函数与 Promise、Generator 函数的比较，async 函数更简洁，更具有语义，但是 async 不要滥用，会造成页面堵塞 class 继承Class 可以通过 extends 关键字实现继承 123class Point &#123;&#125;class ColorPoint extends Point &#123;&#125; 上面代码定义了一个 ColorPoint 类，该类通过 extends 关键字，继承了 Point 类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个 Point 类。下面，我们在 ColorPoint 内部加上代码。 12345678910class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + " " + super.toString(); // 调用父类的toString() &#125;&#125; 上面代码中，constructor 方法和 toString 方法之中，都出现了 super 关键字，它在这里表示父类的构造函数，用来新建父类的 this 对象。 子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类自己的 this 对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用 super 方法，子类就得不到 this 对象。 12345678class ColorPoint extends Point &#123;&#125;// 等同于class ColorPoint extends Point &#123; constructor(...args) &#123; super(...args); &#125;&#125; 另一个需要注意的地方是，在子类的构造函数中，只有调用 super 之后，才可以使用 this 关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有 super 方法才能调用父类实例。 1234567891011121314class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125;&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; this.color = color; // ReferenceError super(x, y); this.color = color; // 正确 &#125;&#125; 上面代码中，子类的 constructor 方法没有调用 super 之前，就使用 this 关键字，结果报错，而放在 super 方法之后就是正确的。 123456789class A &#123; static hello() &#123; console.log("hello world"); &#125;&#125;class B extends A &#123;&#125;B.hello(); // hello world 上面代码中，hello()是 A 类的静态方法，B 继承 A，也继承了 A 的静态方法。 Object.getPrototypeOf()Object.getPrototypeOf 方法可以用来从子类上获取父类。 12Object.getPrototypeOf(ColorPoint) === Point;// true 因此，可以使用这个方法判断，一个类是否继承了另一个类。 super 关键字super 既可以当函数使用，也可以当对象使用 当做函数调用时，代表父类的构造函数,只能用在子类的构造函数之中，用在其他地方就会报错。 1234567class A &#123;&#125;class B extends A &#123; constructor() &#123; super(); &#125;&#125; 上面代码，子类 B 的构造函数中的super(),代表调用父类的构造函数 注意，super 虽然代表了父类 A 的构造函数，但是返回的是子类 B 的实例，即 super 内部的 this 指的是 B 的实例，因此 super()在这里相当于 A.prototype.constructor.call(this)。 super 作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。 1234567891011121314class A &#123; p() &#123; return 2; &#125;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super.p()); // 2 &#125;&#125;let b = new B(); 上面代码中，子类 B 当中的 super.p()，就是将 super 当作一个对象使用。这时，super 在普通方法之中，指向A.prototype，所以 super.p()就相当于 A.prototype.p()。 这里需要注意，由于 super 指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过 super 调用的。 类的 prototype 属性和__proto__属性（1）子类的__proto__属性，表示构造函数的继承，总是指向父类。 （2）子类 prototype 属性的__proto__属性，表示方法的继承，总是指向父类的 123456class A &#123;&#125;class B extends A &#123;&#125;B.__proto__ === A; // trueB.prototype.__proto__ === A.prototype; // true 上面代码中，子类 B 的__proto__属性指向父类 A，子类 B 的 prototype 属性的__proto__属性指向父类 A 的 prototype 属性。 子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，是父类的原型。 12345var p1 = new Point(2, 3);var p2 = new ColorPoint(2, 3, "red");p2.__proto__ === p1.__proto__; // falsep2.__proto__.__proto__ === p1.__proto__; // true 上面代码中，ColorPoint 继承了 Point，导致前者原型的原型是后者的原型。 因此，通过子类实例的__proto__.__proto__属性，可以修改父类实例的行为。 MiXin 模式的实现Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。 1234567const a = &#123; a: "a"&#125;;const b = &#123; b: "b"&#125;;const c = &#123; ...a, ...b &#125;; // &#123;a: 'a', b: 'b'&#125; 上面代码中，c 对象是 a 对象和 b 对象的合成，具有两者的接口。 本文参考: 阮大神]]></content>
      <categories>
        <category>ES6特性</category>
      </categories>
      <tags>
        <tag>JavaScript 前端 ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo和GitHub Page 搭建个人博客]]></title>
    <url>%2F2019%2F06%2F22%2FHexo%E5%92%8CGitHub-Page-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[个人博客的搭建 1.搭建环境安装 Node.js安装 github 2 . 安装 hexo2.1 安装 Hexo，在命令行（即 Git Bash）运行以下命令： 1npm install -g hexo-cli 2.2 创建一个文件夹为项目文件夹，然后在此目录下打开 git bash 执行以下命令初始化 Hexo 1hexo init 2.3 会生成一系列文件，在站点下启动服务，执行命令如下 1hexo server (可简写为 hexo s) 2.4 浏览器访问网址 http://localhost:4000 博客在本地已搭建完成。 3 . 与远程关联，这里我使用的是GitHubPages 注册一个 GitHub 账号 创建一个仓库，仓库名为&lt;GitHub 账号名&gt;.github.io 创建完成后，打开设置找到 GitHub Pages 将本地 Hexo 博客部署到 GithubPages 安装 hexo-deployer-git 插件。在命令行（即 Git Bash）运行以下命令即可： 1npm install hexo-deployer-git --save 修改_config.yml（在站点目录下）。文件末尾修改为： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master 注：上面仓库地址是 ssh 地址，需要生成一个 ssh 秘钥，参考：https://www.jianshu.com/p/f92ed1ca8120 最后下面三行执行命令 123$ hexo clean$ hexo g$ hexo d 博客已经部署到了远程，通过 https://&lt;Github 账号名称&gt;.github.io 即可访问 4. 博客搭建完成，但是默认主题不好看，可以去下载一些主题Theme 选择主题并且 clone]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
