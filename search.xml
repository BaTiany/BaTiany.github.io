<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Ajax和跨域]]></title>
    <url>%2F2019%2F07%2F17%2FAjax%E5%92%8C%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[AjaxAjax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。 这并不是一种新的技术，而是好多旧的技术融合在了一起，而产生了一种新的思想。它包含的技术有：JavaScript、xml、HTML 、dom、XMLHttpRequest 等。 原生 Ajax 的四个步骤1、创建 ajax 对象 1var xhr = new XMLHttpRequest(); 2、监听 ajax 状态的改变，绑定回调函数，判断 ajax 状态等于 4，获取服务端响应的数据 12345678910xhr.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; var responseData = this.responseText; console.log(responseData); //把服务端响应回来的json字符串变为js对象 var result = JSON.parse(responseData); var str = `大名：$&#123;result.username&#125;-芳龄：$&#123;result.age&#125;`; document.getElementById("info").innerHTML = str; &#125;&#125;; 3、建立 Http 连接 1xhr.open("get", "接口地址", true); 4、发送 http 请求 1xhr.send(null); get 与 post 请求的区别1、GET 请求会将参数跟在 URL 后进行传递，而 POST 请求则是作为 HTTP 消息的实体内容发送给 WEB 服务器。 2、 GET 方式请求的数据会被浏览器缓存起来，因此其他人就可以从浏览器的历史记录中读取到这些数据，例如账号和密码等。在某种情况下，GET 方式会带来严重的安全问题。而 POST 方式相对来说就可以避免这些问题。 跨域问题域名、协议、端口不一样就会产生跨域 解决跨域的方法1、通过 CORS 方式跨域 CORS（跨域资源共享，Cross-Origin Resource Sharing）定义一种跨域访问的机制，可以让 AJAX 实现跨域访问。CORS 允许一个域上的网络应用向另一个域提交 AJAX 跨域 请求。实现此功能非常简单，只需由被请求的服务器设置一个响应头即可.1header("Access-Control-Allow-Origin:*"); // 允许任何来源 2、JSONP 的方式 JSONP 之所以能够用来解决跨域方案,主要是因为 脚本拥有跨域能力，客户端网页网页通过添加一个元素，向服务器请求 JSON 数据，这种做法不受同源政策限制 1234567891011121314unction addScriptTag(src) &#123; var script = document.createElement('script'); script.setAttribute("type","text/javascript"); script.src = src; document.body.appendChild(script);&#125;window.onload = function () &#123; addScriptTag('http://example.com/ip?callback=foo');&#125;function foo(data) &#123; console.log('response data: ' + JSON.stringify(data));&#125;; 3、正向代理4、node 中间件实现跨域代理 利用 node + express + http-proxy-middleware 搭建一个 proxy 服务器 前端代码 12345678var xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问http-proxy-middleware代理服务器xhr.open("get", "http://www.domain1.com:3000/login?user=admin", true);xhr.send(); 后台代码 123456789101112131415161718192021222324var express = require("express");var proxy = require("http-proxy-middleware");var app = express();app.use( "/", proxy(&#123; // 代理跨域目标接口 target: "http://www.domain2.com:8080", changeOrigin: true, // 修改响应头信息，实现跨域并允许带cookie onProxyRes: function(proxyRes, req, res) &#123; res.header("Access-Control-Allow-Origin", "http://www.domain1.com"); res.header("Access-Control-Allow-Credentials", "true"); &#125;, // 修改响应信息中的cookie域名 cookieDomainRewrite: "www.domain1.com" // 可以为false，表示不修改 &#125;));app.listen(3000);console.log("Proxy server is listen at port 3000...");]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React生命周期]]></title>
    <url>%2F2019%2F07%2F16%2FReact%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[React 生命周期React 生命周期分为三大阶段，挂载、更新、销毁 挂载阶段constructor()在安装 React 组件之前，会调用它的构造函数。 通常，在 React 中，构造函数仅用于两个目的： 初始化数据this.state。 绑定 this 指向。 123456constructor(props) &#123; super(props); // Don't call this.setState() here! this.state = &#123; counter: 0 &#125;; this.handleClick = this.handleClick.bind(this);&#125; componentDidMount() 组件挂载完成主要用于： 获取异步数据， 操作 dom 之类 render() 渲染默认进来一次，后续如果有更新会再次触发 更新阶段getDerivedStateFromProps()能够让我们根据 props 的数据来设置 state 数据 初始化 render 之前调用一次 后续数据有变化，重新 render 之前又会调用 不能使用 this.setState 需要 return { } | null 如果是 { } ，会将这个 { } 与 state 合并 shouldComponentUpdate(nextProps, nextState)可以用来性能优化，但是不常用 componentDidUpdate() 更新完成componentDidUpdate() 更新发生后立即调用。初始渲染不会调用此方法。 将此作为在更新组件时对 DOM 进行操作的机会。只要您将当前道具与之前的道具进行比较（例如，如果道具未更改，则可能不需要网络请求），这也是进行网络请求的好地方。 123456componentDidUpdate(prevProps) &#123; // Typical usage (don't forget to compare props): if (this.props.userID !== prevProps.userID) &#123; this.fetchData(this.props.userID); &#125;&#125; 销毁阶段componentWillUnmount()componentWillUnmount() 在卸载和销毁组件之前立即调用。在此方法中执行任何必要的清理，例如使计时器无效，取消网络请求或清除在其中创建的任何订阅 componentDidMount()。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React]]></title>
    <url>%2F2019%2F07%2F16%2FReact%2F</url>
    <content type="text"><![CDATA[ReactReact 是一个用于构建用户界面的 JAVASCRIPT 库，主要用于构建 UI，很多人认为 React 是 MVC 中的 V（视图），并且 React 拥有较高的性能，代码逻辑非常简单。React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。 JSX 语法JSX 通俗来说就是 JavaScript 与 XML JSX 语法的特点： 单个根元素 单标签一定要闭合 img 标签一定要有 alt 属性 标签都是小写字母，组件首字母大写 class 要写成 className for 要写成 htmlFor 写 style 样式要写成对象的形式 jsx 的注释：使用 js 的注释 jsx 的插值表达式 使用单个 花括号 来作为表达式 只能是简单的单个表达式，不能是语句也不能是条件或循环语句。 如果要使用条件的，可以采用 三元运算符（三目运算符）{ ‘’ } | { false } | {null} | {undefined} 这些情况的话，会没有任何输出 v-html 需要时 dangerouslySetInnerHTML这个属性，dangerouslySetInnerHTML 这个属性需要接受一个对象的 value 组件React 中没有全局组件的概念，你要使用哪个组件，必须要引入进来使用 组件的定义 函数式组件 定义一个函数，然后 return 出来一段 jsx 语法。这一段 jsx 语法就是这个组件的模板内容 函数名字就是组件的名字，所以首字母要大写 类组件 定义一个类，类名就是组件名（大写首字母） 这个类需要继承 React.Component 这个基础组件类中的 render 函数是必须，render 函数 return 出来是一段 jsx 语法，这一段 jsx 语法就是这个组件的模板内容 组件的注意事项 组件的模板内容，如果需要换行去写的话，那么请使用 ( ) 包裹起来 组件的模板内容是 jsx 语法，所以还需要保证 jsx 特点 组件的 props 属性 调用组件时，在组件标签上写的属性，属性名就是个 prop props 是个集合 ， prop 是具体的某一个 vue 中要使用 props. 首先需要在组件中定义 props 的选项，而 react 中不需要 组件 prop 的校验 需要安装 prop-types 的模块 123npm install --save-dev prop-types//或者yarn add prop-types -D 组件中的 StateState 与 props 类似，但是 state 是私有的，并且完全受控于当前组件 组件有没有状态，主要就看这个组件有没有 state 一般 类组件就可以称为 有状态组件， 函数组件 叫 无状态组件 想让组件自己去更新 UI，那么首先需要让这个组件有自己的 state。 然后 state 如果发生变化，它就会重新渲染。 组件要有变化，两种方式 组件接收到的 props 有了变化 组件自身的 state 有了变化，组件的 state 或 props 有变化，组件就会更新，更新的效果其实就是类组件的 render 函数重新执行了，函数组件重新调用了 PS: 1. 如果要让组件有 state, 首先要确保这个组件是类组件。 要在 构造函数中定义 状态的初始值。 3. 写了 构造函数的话，就必须在构造函数的第一行调用父类的构造函数 super() 组件通信父组件 – &gt; 子组件： porp 子组件 –&gt; 父组件: 调用子组件的时候，传递一个自己的方法下去，这个方法里面有修改自己 state 的功能 子组件通过 this.props.propName() 事件处理函数需要 修改 this 指向 不能使用 apply 与 call,apply 与 call 会立即执行，而 bind 是返回一个新的函数 jsx bind （ 不推荐 ） 箭头函数 （ 不推荐 ） 统一在 构造函数 中去做 this 绑定 （ 推荐 ） 使用 实验性 public class fields 语法 （ 推荐 ）]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMASript 6]]></title>
    <url>%2F2019%2F07%2F16%2FES6%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[ECMASript 6 在 React 和 Vue 中使用了大量的 ES6 语法，本文简单的总结了 ES6 的一些基本特性 Babel转码器Babel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在现有环境执行。可通过以下命令安装在项目目录中。 1npm install --save-dev @babel/core let与const命令let 命令 let 用来声明变量，用法类似于 var，但是声明的变量只在let命令所`在的代码块有效 const 命令 const 声明常量，一旦声明不得修改赋值，必须初始化 let const var的区别 1、var 有变量提升，let 与 const 没有2、var 定义的变量可以修改，如果不初始化会输出 undefined，不会报错。3、const 定义的变量不可以修改，而且必须初始化。4、let 是块级作用域，函数内部使用 let 定义后，对函数外部无影响。 解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。 12345var obj = &#123; name: "老王", age: 20 &#125;;// 解构为var &#123; name, age &#125; = obj;name; // 老王age; // 20 扩展运算符扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。 12let str = ["a", "b", "c"];console.log(...str); // a,b,c 可用于复制数组 数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。 12345const a1 = [1, 2];// 写法一const a2 = [...a1];// 写法二const [...a2] = a1; 模板字符串模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。 123456789$("#result").append( "There are &lt;b&gt;" + basket.count + "&lt;/b&gt; " + "items in your basket, " + "&lt;em&gt;" + basket.onSale + "&lt;/em&gt; are on sale!"); 上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。 12345$("#result").append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 模板字符串嵌入变量，需要将变量写入${}中 123let name = "Bob", time = "today";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`; 箭头函数ES6 允许使用“箭头”（=&gt;）定义函数。 1234567891011var f = () =&gt; 5;// 等同于var f = function() &#123; return 5;&#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; SymbolES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。 Promise 对象promis 简介 Promise 对象用于异步操作，它表示一个尚未完成且预计在未来完成的异步操作。 Promise 对象有两个特点 （1）对象的状态不受外界影响。promise 对象代表一个异步操作，分为三个状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败） （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。改变状态的两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。 Promise 对象的缺点 （1）无法取消，一旦新建会立刻执行 （2）如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部 （3）当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 Promsie 用法Promise 对象是一个构造函数，用来生成 Promise 实例 123456789const promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); Promise 对象接收两个参数 resolve() 在异步操作成功时调用，并将异步操作的结果，作为参数传递出去 reject() 在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Generator 函数Generator 函数是 ES6 提供的一种异步编程解决方案。 特征：function 与函数名之间有个星号（*） 函数体内部使用yield表达式 12345function* helloWorldGenerator() &#123; yield "hello"; yield "world"; return "ending";&#125; async 函数async 函数就是 Generator 函数的语法糖，把 Generator 函数里面的星号（*）替换成 async，yield 替换成 await。 await 函数返回一个 Promise 对象 123456789101112async function timeout(ms) &#123; await new Promise(resolve =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value);&#125;asyncPrint("hello world", 50); 上面代码指定 50 毫秒以后，输出 hello world。 使用注意点 await 返回一个 Promise 对象，所以 await 命令最好放在 try…catch 语句中 123456789101112131415161718192021const sleep = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(123); resolve("abc"); // reject(new Error("我错了")); &#125;, 1000); &#125;);&#125;;const main = async () =&gt; &#123; try &#123; let str = await sleep(); console.log(str); console.log(456); &#125; catch (error) &#123; console.log(error.message); &#125;&#125;;main(); await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。 async 函数与 Promise、Generator 函数的比较，async 函数更简洁，更具有语义，但是 async 不要滥用，会造成页面堵塞 class 继承Class 可以通过 extends 关键字实现继承 123class Point &#123;&#125;class ColorPoint extends Point &#123;&#125; 上面代码定义了一个 ColorPoint 类，该类通过 extends 关键字，继承了 Point 类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个 Point 类。下面，我们在 ColorPoint 内部加上代码。 12345678910class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + " " + super.toString(); // 调用父类的toString() &#125;&#125; 上面代码中，constructor 方法和 toString 方法之中，都出现了 super 关键字，它在这里表示父类的构造函数，用来新建父类的 this 对象。 子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类自己的 this 对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用 super 方法，子类就得不到 this 对象。 12345678class ColorPoint extends Point &#123;&#125;// 等同于class ColorPoint extends Point &#123; constructor(...args) &#123; super(...args); &#125;&#125; 另一个需要注意的地方是，在子类的构造函数中，只有调用 super 之后，才可以使用 this 关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有 super 方法才能调用父类实例。 1234567891011121314class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125;&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; this.color = color; // ReferenceError super(x, y); this.color = color; // 正确 &#125;&#125; 上面代码中，子类的 constructor 方法没有调用 super 之前，就使用 this 关键字，结果报错，而放在 super 方法之后就是正确的。 123456789class A &#123; static hello() &#123; console.log("hello world"); &#125;&#125;class B extends A &#123;&#125;B.hello(); // hello world 上面代码中，hello()是 A 类的静态方法，B 继承 A，也继承了 A 的静态方法。 Object.getPrototypeOf()Object.getPrototypeOf 方法可以用来从子类上获取父类。 12Object.getPrototypeOf(ColorPoint) === Point;// true 因此，可以使用这个方法判断，一个类是否继承了另一个类。 super 关键字super 既可以当函数使用，也可以当对象使用 当做函数调用时，代表父类的构造函数,只能用在子类的构造函数之中，用在其他地方就会报错。 1234567class A &#123;&#125;class B extends A &#123; constructor() &#123; super(); &#125;&#125; 上面代码，子类 B 的构造函数中的super(),代表调用父类的构造函数 注意，super 虽然代表了父类 A 的构造函数，但是返回的是子类 B 的实例，即 super 内部的 this 指的是 B 的实例，因此 super()在这里相当于 A.prototype.constructor.call(this)。 super 作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。 1234567891011121314class A &#123; p() &#123; return 2; &#125;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super.p()); // 2 &#125;&#125;let b = new B(); 上面代码中，子类 B 当中的 super.p()，就是将 super 当作一个对象使用。这时，super 在普通方法之中，指向A.prototype，所以 super.p()就相当于 A.prototype.p()。 这里需要注意，由于 super 指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过 super 调用的。 类的 prototype 属性和__proto__属性（1）子类的__proto__属性，表示构造函数的继承，总是指向父类。 （2）子类 prototype 属性的__proto__属性，表示方法的继承，总是指向父类的 123456class A &#123;&#125;class B extends A &#123;&#125;B.__proto__ === A; // trueB.prototype.__proto__ === A.prototype; // true 上面代码中，子类 B 的__proto__属性指向父类 A，子类 B 的 prototype 属性的__proto__属性指向父类 A 的 prototype 属性。 子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，是父类的原型。 12345var p1 = new Point(2, 3);var p2 = new ColorPoint(2, 3, "red");p2.__proto__ === p1.__proto__; // falsep2.__proto__.__proto__ === p1.__proto__; // true 上面代码中，ColorPoint 继承了 Point，导致前者原型的原型是后者的原型。 因此，通过子类实例的__proto__.__proto__属性，可以修改父类实例的行为。 MiXin 模式的实现Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。 1234567const a = &#123; a: "a"&#125;;const b = &#123; b: "b"&#125;;const c = &#123; ...a, ...b &#125;; // &#123;a: 'a', b: 'b'&#125; 上面代码中，c 对象是 a 对象和 b 对象的合成，具有两者的接口。 本文参考: 阮大神]]></content>
      <categories>
        <category>ES6特性</category>
      </categories>
      <tags>
        <tag>JavaScript 前端 ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo和GitHub Page 搭建个人博客]]></title>
    <url>%2F2019%2F06%2F22%2FHexo%E5%92%8CGitHub-Page-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[个人博客的搭建 1.搭建环境安装 Node.js安装 github 2 . 安装 hexo2.1 安装 Hexo，在命令行（即 Git Bash）运行以下命令： 1npm install -g hexo-cli 2.2 创建一个文件夹为项目文件夹，然后在此目录下打开 git bash 执行以下命令初始化 Hexo 1hexo init 2.3 会生成一系列文件，在站点下启动服务，执行命令如下 1hexo server (可简写为 hexo s) 2.4 浏览器访问网址 http://localhost:4000 博客在本地已搭建完成。 3 . 与远程关联，这里我使用的是GitHubPages 注册一个 GitHub 账号 创建一个仓库，仓库名为&lt;GitHub 账号名&gt;.github.io 创建完成后，打开设置找到 GitHub Pages 将本地 Hexo 博客部署到 GithubPages 安装 hexo-deployer-git 插件。在命令行（即 Git Bash）运行以下命令即可： 1npm install hexo-deployer-git --save 修改_config.yml（在站点目录下）。文件末尾修改为： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master 注：上面仓库地址是 ssh 地址，需要生成一个 ssh 秘钥，参考：https://www.jianshu.com/p/f92ed1ca8120 最后下面三行执行命令 123$ hexo clean$ hexo g$ hexo d 博客已经部署到了远程，通过 https://&lt;Github 账号名称&gt;.github.io 即可访问 4. 博客搭建完成，但是默认主题不好看，可以去下载一些主题Theme 选择主题并且 clone]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
